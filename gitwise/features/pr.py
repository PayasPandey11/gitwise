"""Pull request creation feature for GitWise."""

import subprocess
import re
# import json # No longer needed after removing old functions
from typing import List, Dict, Tuple, Optional
# from git import Repo, Commit # No longer needed after removing old functions
# from gitwise.gitutils import get_current_branch # This specific import is not needed if using core.git.get_current_branch
from gitwise.llm import generate_pr_title, get_llm_response
from gitwise.features.pr_enhancements import enhance_pr_description, get_pr_labels
from gitwise.prompts import PR_DESCRIPTION_PROMPT
from rich.console import Console
# from rich.panel import Panel # Unused
# from rich.table import Table # Unused
# from rich.progress import Progress, SpinnerColumn, TextColumn # Progress unused directly here, but used by components.show_spinner
# from rich.prompt import Confirm # Unused
# from rich import print as rprint # Unused
from gitwise.core import git
from gitwise.ui import components
import os
import tempfile
import typer

console = Console()

# Removed old get_commits_since_last_pr (GitPython version)
# Removed old create_pr (placeholder)
# Removed old create_pull_request (older implementation)

def _clean_pr_body(raw_body: str) -> str:
    """Programmatically cleans the PR body generated by LLM.
    Removes common preamble and unwanted sections like 'Contributors'.
    """
    cleaned_body = raw_body.strip()
    
    # Remove common preambles if they exist before a markdown heading or key section
    # For example, "Here is the PR description:" or similar chatty starts.
    # This looks for the first real markdown content (e.g., #, ##, ###, - , * , **Summary**)
    preamble_patterns = [
        r"^(.*?)(?=^#\s|^- |^\* |^\*\*Summary of Changes\*\*)M"
    ]
    # Try to find if there's a preamble before the main content using a simplified check
    lines = cleaned_body.split('\n')
    start_index = 0
    for i, line in enumerate(lines):
        if line.startswith(("##", "# ", "###", "- ", "* ", "**Summary")):
            start_index = i
            break
        if i < 3 and not line.startswith("##") and not line.startswith("# ") and not line.startswith("###") and "Summary of Changes" not in line and "Key Enhancements" not in line and "Key Features" not in line:
            # Likely preamble if first few lines don't look like markdown content headers
            continue
        else:
            # If it looks like content, stop assuming preamble
            if i==0: # No preamble found
                start_index = 0
            else:
                start_index = i # Content started
            break
            
    if start_index > 0 and start_index < len(lines):
        cleaned_body = "\n".join(lines[start_index:])
    
    # Remove "Contributors" or "Acknowledgements" sections
    section_patterns_to_remove = [
        r"(^|\n)##?\s*(?:🙏\s*)?(?:Contributors|Acknowledgements|Special Thanks|Next Steps)\s*($|\n).*?(?=(^|\n)##?\s|\Z)"
    ]
    for pattern in section_patterns_to_remove:
        cleaned_body = re.sub(pattern, "", cleaned_body, flags=re.IGNORECASE | re.MULTILINE | re.DOTALL).strip()
        
    return cleaned_body.strip()

def validate_branch_name(branch: str) -> bool:
    """Validate branch name against naming conventions."""
    # Protected branches
    protected = {"main", "master", "develop"}
    if branch in protected:
        return False
    
    # Branch name pattern
    pattern = r"^(feature|fix|docs|chore|refactor|test|style|perf|ci|build|revert)/[a-z0-9-]+$"
    return bool(re.match(pattern, branch))

def get_commits_since_last_pr(base_branch: str) -> List[Dict]:
    """Get commits that haven't been included in a PR yet, relative to the given base_branch."""
    try:
        # Ensure the local reference of the base branch is up-to-date with its remote counterpart.
        # This helps in getting an accurate commit list similar to what GitHub would show.
        # We fetch the specific base branch from origin.
        # Only run fetch if base_branch is likely a remote-tracking branch or can be fetched.
        # For simplicity, always try to fetch the base branch ref from origin.
        # This assumes 'origin' is the relevant remote.
        fetch_result = subprocess.run(["git", "fetch", "origin", base_branch], capture_output=True, text=True)
        if fetch_result.returncode != 0:
            # Log a warning but proceed; could be an offline scenario or base_branch is purely local.
            components.show_warning(f"Could not fetch remote state for base branch '{base_branch}'. Commit list might be inaccurate. Error: {fetch_result.stderr.strip()}")

        # Determine the correct reference for the base branch for comparison.
        # If base_branch is a simple name like "main", we usually want to compare against "origin/main".
        # If it already contains "/", like "origin/main", use it as is.
        # This ensures we're comparing against the fetched remote state.
        effective_base_for_diff = base_branch
        if "/" not in base_branch:
            effective_base_for_diff = f"origin/{base_branch}"
            # However, ensure that this remote ref exists locally after fetch.
            # `git rev-parse --verify origin/main` would check.
            # For now, assume fetch makes it available.
            # A `git rev-parse --verify {effective_base_for_diff}` could be added for robustness.
        
        # If fetch failed, effective_base_for_diff (e.g. origin/main) might not be updated or exist.
        # In such a case, falling back to just `base_branch` (local) might be safer than a non-existent `origin/base_branch`.
        if fetch_result.returncode != 0:
             effective_base_for_diff = base_branch # Fallback to local base if fetch failed
             components.show_warning(f"Using local '{base_branch}' for commit comparison due to fetch issue.")

        diff_range = f"{effective_base_for_diff}..HEAD"
        components.console.print(f"[dim]Analyzing commits in range: {diff_range} (Base: '{base_branch}', Effective for diff: '{effective_base_for_diff}')[/dim]")

        result = subprocess.run(
            ["git", "log", diff_range, "--pretty=format:%H|%s|%an"],
            capture_output=True,
            text=True
        )
        
        if not result.stdout.strip():
            return []
            
        commits = []
        for line in result.stdout.strip().split('\n'):
            hash_, message, author = line.split('|')
            commits.append({
                'hash': hash_,
                'message': message,
                'author': author
            })
            
        return commits
    except Exception as e:
        components.show_error(f"Failed to get commits: {str(e)}")
        return []

def pr_command(
    use_labels: bool = False,
    use_checklist: bool = False,
    skip_general_checklist: bool = False,
    title: Optional[str] = None,
    base: Optional[str] = None,
    draft: bool = False,
    skip_prompts: bool = False
) -> None:
    """Create a pull request with AI-generated description.
    
    Args:
        use_labels: Whether to add labels to the PR
        use_checklist: Whether to add a checklist to the PR description
        skip_general_checklist: Whether to skip general checklist items
        title: Custom title for the PR
        base: Base branch for the PR
        draft: Whether to create a draft PR
        skip_prompts: Whether to skip interactive prompts (used when called from push)
    """
    try:
        # Get current branch
        current_branch = git.get_current_branch()
        if not current_branch:
            components.show_error("Not on any branch")
            return

        # Get base branch
        base_branch = base or "main"
        
        # Get commits since last PR
        components.show_section("Analyzing Changes")
        with components.show_spinner("Checking for commits...") as progress:
            commits = get_commits_since_last_pr(base_branch)
            if not commits:
                components.show_warning("No commits to create PR for")
                return

        # Generate PR title using LLM
        pr_generated_title = title
        if not pr_generated_title:
            with components.show_spinner("Generating PR title..."):
                pr_generated_title = generate_pr_title(commits)

        # Show commits that will be included
        components.show_section("Commits to Include")
        for commit in commits:
            components.console.print(f"[bold cyan]{commit['hash'][:7]}[/bold cyan] {commit['message']}")

        # Generate PR description
        components.show_section("Generating PR Description")
        pr_body = ""
        try:
            with components.show_spinner("Analyzing changes...") as progress:
                # Use the local pr.py generate_pr_description, which calls get_repository_info
                raw_pr_body = generate_pr_description(commits) 
                if not raw_pr_body:
                    raise ValueError("Failed to generate PR description (empty LLM response)")
                pr_body = _clean_pr_body(raw_pr_body)
        except Exception as e:
            components.show_error(f"Could not generate PR description: {str(e)}")
            components.show_prompt(
                "Would you like to try again?",
                options=["Yes", "No"],
                default="No"
            )
            if not typer.confirm("", default=False):
                return
            # Try one more time
            try:
                with components.show_spinner("Retrying...") as progress:
                    raw_pr_body = generate_pr_description(commits)
                    if not raw_pr_body:
                        components.show_error("Failed to generate PR description again (empty LLM response)")
                        return
                    pr_body = _clean_pr_body(raw_pr_body)
            except Exception as e:
                components.show_error(f"Failed to generate PR description: {str(e)}")
                return

        # Enhance PR description with checklist if requested
        # Labels will be handled separately with gh command
        final_labels = []
        if use_labels:
            with components.show_spinner("Generating labels..."):
                final_labels = get_pr_labels(commits) # Get labels based on commits
        
        if use_checklist:
            with components.show_spinner("Generating checklist..."):
                # Pass base_branch to enhance_pr_description for accurate checklist generation
                pr_body, _ = enhance_pr_description(commits, pr_body, use_labels=False, use_checklist=True, skip_general_checklist=skip_general_checklist, base_branch_for_checklist=base_branch)

        # Show the generated/enhanced description
        components.show_section("Suggested PR Description")
        components.console.print(f"[bold]Title:[/bold] {pr_generated_title}")
        if final_labels:
            components.console.print(f"[bold]Labels:[/bold] {', '.join(final_labels)}")
        components.console.print(f"[bold]Body:[/bold]\n{pr_body}")

        if not skip_prompts:
            # Ask about creating PR
            components.show_prompt(
                "Would you like to create this pull request?",
                options=["Yes", "Edit description", "No"],
                default="Yes"
            )
            choice = typer.prompt("", type=int, default=1)

            if choice == 3:  # No
                components.show_warning("PR creation cancelled")
                return

            if choice == 2:  # Edit
                with tempfile.NamedTemporaryFile(suffix=".tmp", delete=False, mode="w+") as tf:
                    tf.write(pr_body) # Edit the potentially enhanced body
                    tf.flush()
                    editor = os.environ.get("EDITOR", "vi")
                    # os.system(f'{editor} {tf.name}')
                    subprocess.run([editor, tf.name], check=True)
                    tf.seek(0)
                    pr_body = tf.read().strip()
                os.unlink(tf.name)
                
                if not pr_body.strip():
                    components.show_error("PR description cannot be empty")
                    return
                    
                components.show_section("Edited PR Description")
                components.console.print(pr_body)

                components.show_prompt(
                    "Proceed with PR creation?",
                    options=["Yes", "No"],
                    default="Yes"
                )
                if not typer.confirm("", default=True):
                    components.show_warning("PR creation cancelled")
                    return

            # Create the PR
            components.show_section("Creating Pull Request")
            with components.show_spinner("Creating PR...") as progress:
                try:
                    print("trying  to create PR")
                    # Use GitHub CLI if available
                    cmd = [
                        "gh", "pr", "create",
                        "--title", pr_generated_title or f"feat: {commits[0]['message']}", # Fallback if title is empty
                        "--body", pr_body,
                        "--base", base_branch
                    ]
                    if draft:
                        cmd.append("--draft")
                    for label in final_labels:
                        cmd.extend(["--label", label])
                    
                    result = subprocess.run(
                        cmd,
                        capture_output=True,
                        text=True
                    )
                    
                    if result.returncode == 0:
                        components.show_success("Pull request created successfully")
                        components.console.print(result.stdout)
                    else:
                        components.show_error("Failed to create pull request")
                        error_details = f"`gh pr create` exited with code {result.returncode}.\n"
                        if result.stderr:
                            error_details += f"\nStderr:\n{result.stderr}"
                        else:
                            error_details += "\nStderr was empty."
                        if result.stdout:
                            error_details += f"\nStdout:\n{result.stdout}"
                        components.console.print(error_details)
                        return
                except FileNotFoundError:
                    components.show_error("GitHub CLI (gh) not found. Please install it to create PRs.")
                    components.console.print("\n[dim]You can install it from: https://cli.github.com/[/dim]")
                    return

    except Exception as e:
        components.show_error(str(e))

def create_pull_request(title: str, body: str, base: str, head: str, draft: bool = False) -> Dict:
    """Create a pull request using GitHub API."""
    # Implementation depends on your GitHub API integration
    pass

def generate_pr_description(commits: List[Dict]) -> str:
    """Generate a PR description from commits.
    
    Args:
        commits: List of commit dictionaries.
        
    Returns:
        Formatted PR description string.
    """
    if not commits:
        return ""
        
    # Prepare commit messages for LLM
    commit_text = "\n".join([
        f"- {commit['message']} ({commit['author']})"
        for commit in commits
    ])
    
    # Get repository info
    repo_info = get_repository_info()
    repo_name = repo_info.get("name", "the repository")
    repo_url = repo_info.get("url", "")
    
    # Generate PR description using LLM
    messages = [
        {
            "role": "system",
            "content": f"""You are a technical writer creating a pull request description for {repo_name}.
            Create clear, concise, and user-friendly PR descriptions that:
            1. Summarize the changes and their purpose
            2. Group related changes together
            3. Use clear, non-technical language where possible
            4. Include any breaking changes or migration steps
            5. Mention contributors if there are significant changes
            
            Format the description in markdown with appropriate sections."""
        },
        {
            "role": "user",
            "content": f"""Create a PR description for the following commits:

            {commit_text}"""
        }
    ]
    
    try:
        description = get_llm_response(messages)
        if not description:
            raise ValueError("Empty PR description generated")
        return description
    except Exception as e:
        components.show_error(f"Could not generate PR description: {str(e)}")
        return ""

def get_repository_info() -> Dict[str, str]:
    """Get repository information.
    
    Returns:
        Dictionary with repository information.
    """
    info = {}
    
    # Get repository URL
    result = subprocess.run(
        ["git", "config", "--get", "remote.origin.url"],
        capture_output=True,
        text=True
    )
    info["url"] = result.stdout.strip()
    
    # Get repository name
    if info["url"]:
        # Extract name from URL
        match = re.search(r"[:/]([^/]+/[^/]+?)(?:\.git)?$", info["url"])
        if match:
            info["name"] = match.group(1)
    
    return info 