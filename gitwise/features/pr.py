"""Pull request creation feature for GitWise."""

import subprocess
import re
# import json # No longer needed
from typing import List, Dict, Tuple, Optional
# from git import Repo, Commit # No longer needed
# from gitwise.gitutils import get_current_branch # Using core.git.get_current_branch
from gitwise.llm import get_llm_response
from gitwise.prompts import PR_DESCRIPTION_PROMPT, PROMPT_PR_DESCRIPTION
from gitwise.features.pr_enhancements import enhance_pr_description, get_pr_labels
from rich.console import Console
# from rich.panel import Panel # Unused
# from rich.table import Table # Unused
# from rich.progress import Progress, SpinnerColumn, TextColumn # Progress unused directly here
# from rich.prompt import Confirm # Unused
# from rich import print as rprint # Unused
from gitwise.core import git
from gitwise.ui import components
import os
import tempfile
import typer
from gitwise.llm.offline import ensure_offline_model_ready
from gitwise.core.git import get_default_remote_branch
from gitwise.config import get_llm_backend, load_config, ConfigError
from gitwise.features.pr_templates import render_pr_description

console = Console()

# Removed old get_commits_since_last_pr (GitPython version)
# Removed old create_pr (placeholder)
# Removed old create_pull_request (older implementation)

def _clean_pr_body(raw_body: str) -> str:
    """Programmatically cleans the PR body generated by LLM.
    Removes common preamble and unwanted sections like 'Contributors'.
    """
    cleaned_body = raw_body.strip()
    
    # Remove common preambles if they exist before a markdown heading or key section
    # For example, "Here is the PR description:" or similar chatty starts.
    # This looks for the first real markdown content (e.g., #, ##, ###, - , * , **Summary**)
    preamble_patterns = [
        r"^(.*?)(?=^#\s|^- |^\* |^\*\*Summary of Changes\*\*)M"
    ]
    # Try to find if there's a preamble before the main content using a simplified check
    lines = cleaned_body.split('\n')
    start_index = 0
    for i, line in enumerate(lines):
        if line.startswith(("##", "# ", "###", "- ", "* ", "**Summary")):
            start_index = i
            break
        if i < 3 and not line.startswith("##") and not line.startswith("# ") and not line.startswith("###") and "Summary of Changes" not in line and "Key Enhancements" not in line and "Key Features" not in line:
            # Likely preamble if first few lines don't look like markdown content headers
            continue
        else:
            # If it looks like content, stop assuming preamble
            if i==0: # No preamble found
                start_index = 0
            else:
                start_index = i # Content started
            break
            
    if start_index > 0 and start_index < len(lines):
        cleaned_body = "\n".join(lines[start_index:])
    
    # Remove "Contributors" or "Acknowledgements" sections
    section_patterns_to_remove = [
        r"(^|\n)##?\s*(?:🙏\s*)?(?:Contributors|Acknowledgements|Special Thanks|Next Steps)\s*($|\n).*?(?=(^|\n)##?\s|\Z)"
    ]
    for pattern in section_patterns_to_remove:
        cleaned_body = re.sub(pattern, "", cleaned_body, flags=re.IGNORECASE | re.MULTILINE | re.DOTALL).strip()
        
    return cleaned_body.strip()

def validate_branch_name(branch: str) -> bool:
    """Validate branch name against naming conventions."""
    # Protected branches
    protected = {"main", "master", "develop"}
    if branch in protected:
        return False
    
    # Branch name pattern
    pattern = r"^(feature|fix|docs|chore|refactor|test|style|perf|ci|build|revert)/[a-z0-9-]+$"
    return bool(re.match(pattern, branch))

def get_commits_since_last_pr(base_branch: str) -> List[Dict]:
    """Get commits unique to the current branch (not yet merged into base_branch)."""
    try:
        # Find the merge base (common ancestor) between base_branch and HEAD
        merge_base_result = subprocess.run([
            "git", "merge-base", base_branch, "HEAD"
        ], capture_output=True, text=True)
        if merge_base_result.returncode != 0 or not merge_base_result.stdout.strip():
            components.show_error(f"Could not determine merge base with {base_branch}: {merge_base_result.stderr.strip()}")
            return []
        merge_base = merge_base_result.stdout.strip()

        # Get commits in HEAD that are not in base_branch (i.e., not reachable from merge base)
        log_range = f"{merge_base}..HEAD"
        components.console.print(f"[dim]Analyzing commits in range: {log_range} (Base: '{base_branch}', Merge base: '{merge_base}')[/dim]")

        result = subprocess.run(
            ["git", "log", log_range, "--pretty=format:%H|%s|%an"],
            capture_output=True,
            text=True
        )
        if not result.stdout.strip():
            return []
        commits = []
        for line in result.stdout.strip().split('\n'):
            hash_, message, author = line.split('|')
            commits.append({
                'hash': hash_,
                'message': message,
                'author': author
            })
        return commits
    except Exception as e:
        components.show_error(f"Failed to get commits: {str(e)}")
        return []

def get_pr_commits(base_branch: str) -> List[Dict]:
    """Return commits unique to the current branch (not yet merged into base_branch)."""

    import subprocess
    from gitwise.ui import components
    try:
        # Find the merge base (common ancestor) between base_branch and HEAD
        merge_base_result = subprocess.run([
            "git", "merge-base", base_branch, "HEAD"
        ], capture_output=True, text=True)
        if merge_base_result.returncode != 0 or not merge_base_result.stdout.strip():
            components.show_error(f"Could not determine merge base with {base_branch}: {merge_base_result.stderr.strip()}")
            return []
        merge_base = merge_base_result.stdout.strip()

        # Get commits in HEAD that are not in base_branch (i.e., not reachable from merge base)
        log_range = f"{merge_base}..HEAD"
        components.console.print(f"[dim]Analyzing commits in range: {log_range} (Base: '{base_branch}', Merge base: '{merge_base}')[/dim]")

        result = subprocess.run(
            ["git", "log", log_range, "--pretty=format:%H|%s|%an"],
            capture_output=True,
            text=True
        )
        if not result.stdout.strip():
            return []
        commits = []
        for line in result.stdout.strip().split('\n'):
            hash_, message, author = line.split('|')
            commits.append({
                'hash': hash_,
                'message': message,
                'author': author
            })
        return commits
    except Exception as e:
        components.show_error(f"Failed to get commits: {str(e)}")
        return []

def generate_pr_title(commits: List[Dict]) -> str:
    """Generate a PR title from a list of commits."""
    if not commits:
        return ""
    first_commit = commits[0]
    title = first_commit["message"].split("\n")[0]
    if len(commits) > 1:
        title = f"{title} (+{len(commits)-1} more commits)"
    return title

def generate_pr_description(
    commits: List[Dict], repo_url: str, repo_name: str, guidance: str = ""
) -> str:
    """Generate a PR description using LLM prompt only. The LLM outputs the full Markdown body."""
    formatted_commits = "\n".join([
        f"- {commit['message']} ({commit['author']})" for commit in commits
    ])
    prompt = PROMPT_PR_DESCRIPTION.replace("{{commits}}", formatted_commits).replace("{{guidance}}", guidance)
    llm_output = get_llm_response(prompt)
    return llm_output.strip()

def create_github_pr(
    title: str, body: str, base: str, labels: List[str], draft: bool = False
) -> None:
    """Create a pull request using the GitHub CLI."""
    _create_gh_pr(title, body, base, labels, draft)

def pr_command(
    use_labels: bool = False,
    use_checklist: bool = False,
    skip_general_checklist: bool = False,
    title: Optional[str] = None,
    base: Optional[str] = None,
    draft: bool = False,
    skip_prompts: bool = False
) -> bool:
    """Create a pull request with AI-generated description.
    Orchestrates commit collection, title/description generation, and PR creation.
    Returns True if PR was created or already exists, False otherwise.
    """
    try:
        # Config check
        try:
            load_config()
        except ConfigError as e:
            components.show_error(str(e))
            if typer.confirm("Would you like to run 'gitwise init' now?", default=True):
                from gitwise.cli.init import init_command
                init_command()
            return False
        # Detect and show current LLM backend
        backend = get_llm_backend()
        backend_display = {
            "ollama": "Ollama (local server)",
            "offline": "Offline (local model)",
            "online": "Online (OpenRouter)"
        }.get(backend, backend)
        components.show_section(f"[AI] LLM Backend: {backend_display}")

        # Only check for offline model if backend is offline
        if backend == "offline":
            try:
                ensure_offline_model_ready()
            except Exception as e:
                components.show_error(f"Failed to load offline model: {e}")
                return False

        # Get current branch
        current_branch = git.get_current_branch()
        if not current_branch:
            components.show_error("Not on any branch")
            return False

        # Get base branch (always use remote-tracking branch)
        try:
            # Always resolve to remote-tracking branch for PRs
            base_branch = base or get_default_remote_branch()
        except Exception as e:
            components.show_error(f"Could not determine default remote branch: {e}")
            return False
        
        # Get commits for PR
        components.show_section("Analyzing Changes")
        with components.show_spinner("Checking for commits...") as progress:
            commits = get_pr_commits(base_branch)
            if not commits:
                components.show_warning("No commits to create PR for")
                return False

        # Generate PR title
        pr_generated_title = title or generate_pr_title(commits)

        # Show commits that will be included
        components.show_section("Commits to Include")
        for commit in commits:
            components.console.print(f"[bold cyan]{commit['hash'][:7]}[/bold cyan] {commit['message']}")

        # Generate PR description
        components.show_section("Generating PR Description")
        pr_body = ""
        repo_info = get_repository_info() # Get repo_info once
        repo_name = repo_info.get("name", "the repository")
        repo_url = repo_info.get("url", "")

        try:
            with components.show_spinner("Analyzing changes...") as progress:
                raw_pr_body = generate_pr_description(commits, repo_url, repo_name) 
                if not raw_pr_body:
                    raise ValueError("Failed to generate PR description (empty LLM response)")
                pr_body = _clean_pr_body(raw_pr_body)
        except Exception as e:
            components.show_error(f"Could not generate PR description: {str(e)}")
            components.show_prompt(
                "Would you like to try again?",
                options=["Yes", "No"],
                default="No"
            )
            if not typer.confirm("", default=False):
                return False
            # Try one more time
            try:
                with components.show_spinner("Retrying...") as progress:
                    raw_pr_body = generate_pr_description(commits, repo_url, repo_name)
                    if not raw_pr_body:
                        components.show_error("Failed to generate PR description again (empty LLM response)")
                        return False
                    pr_body = _clean_pr_body(raw_pr_body)
            except Exception as e:
                components.show_error(f"Failed to generate PR description: {str(e)}")
                return False

        # Enhance PR description with checklist if requested
        final_labels = []
        if use_labels:
            with components.show_spinner("Generating labels..."):
                final_labels = get_pr_labels(commits) # Get labels based on commits
        
        if use_checklist:
            with components.show_spinner("Generating checklist..."):
                pr_body, _ = enhance_pr_description(commits, pr_body, use_labels=False, use_checklist=True, skip_general_checklist=skip_general_checklist, base_branch_for_checklist=base_branch)

        # Show the generated/enhanced description
        components.show_section("Suggested PR Description")
        components.console.print(f"[bold]Title:[/bold] {pr_generated_title}")
        if final_labels:
            components.console.print(f"[bold]Labels:[/bold] {', '.join(final_labels)}")
        components.console.print(f"[bold]Body:[/bold]\n{pr_body}")

        if skip_prompts:
            create_github_pr(title=pr_generated_title, body=pr_body, base=base_branch, labels=final_labels, draft=draft)
            return True
        else:
            components.show_prompt(
                "Would you like to create this pull request?",
                options=["Yes", "Edit description", "No"],
                default="Yes"
            )
            choice = typer.prompt("", type=int, default=1)

            if choice == 3:  # No
                components.show_warning("PR creation cancelled")
                return False

            if choice == 2:  # Edit
                import tempfile, os, subprocess
                with tempfile.NamedTemporaryFile(suffix=".tmp", delete=False, mode="w+") as tf:
                    tf.write(pr_body) # Edit the potentially enhanced body
                    tf.flush()
                    editor = os.environ.get("EDITOR", "vi")
                    subprocess.run([editor, tf.name], check=True)
                    tf.seek(0)
                    pr_body = tf.read().strip()
                os.unlink(tf.name)
                
                if not pr_body.strip():
                    components.show_error("PR description cannot be empty")
                    return False
                    
                components.show_section("Edited PR Description")
                components.console.print(pr_body)

                components.show_prompt(
                    "Proceed with PR creation using the edited description?",
                    options=["Yes", "No"],
                    default="Yes"
                )
                if not typer.confirm("", default=True):
                    components.show_warning("PR creation cancelled")
                    return False
            
            create_github_pr(title=pr_generated_title, body=pr_body, base=base_branch, labels=final_labels, draft=draft)
            return True

    except Exception as e:
        components.show_error(str(e))
        return False

def _create_gh_pr(title: str, body: str, base: str, labels: List[str], draft: bool = False) -> None:
    """Internal function to create a pull request using the gh CLI."""
    # Removed `commits` from args as `gh pr create` infers this.
    components.show_section("Creating Pull Request via gh CLI")
    with components.show_spinner("Running `gh pr create`...") as progress: # Changed spinner message
        try:
            # Check if a PR already exists for this branch into the base branch
            current_branch_result = subprocess.run([
                "git", "rev-parse", "--abbrev-ref", "HEAD"
            ], capture_output=True, text=True, check=True)
            current_branch = current_branch_result.stdout.strip()
            pr_list_cmd = [
                "gh", "pr", "list",
                "--head", current_branch,
                "--base", base,
                "--state", "open",
                "--json", "url"
            ]
            pr_list_result = subprocess.run(
                pr_list_cmd,
                capture_output=True,
                text=True
            )
            if pr_list_result.returncode == 0 and pr_list_result.stdout.strip():
                import json
                pr_list = json.loads(pr_list_result.stdout)
                if pr_list:
                    pr_url = pr_list[0].get("url")
                    components.show_success(f"A pull request for this branch already exists: {pr_url}")
                    return
            # If no existing PR, proceed to create
            cmd = [
                "gh", "pr", "create",
                "--title", title, 
                "--body", body,
                "--base", base
            ]
            if draft:
                cmd.append("--draft")
            for label in labels:
                cmd.extend(["--label", label])
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True
            )
            if result.returncode == 0:
                components.show_success("Pull request created successfully by gh CLI.")
                components.console.print(result.stdout)
            else:
                components.show_error("Failed to create pull request using gh CLI.")
                error_details = f"`gh pr create` exited with code {result.returncode}.\n"
                if result.stderr:
                    error_details += f"\nStderr:\n{result.stderr}"
                else:
                    error_details += "\nStderr was empty."
                if result.stdout: # Log stdout too if stderr is empty but command failed
                    error_details += f"\nStdout:\n{result.stdout}"
                components.console.print(error_details)
        except FileNotFoundError:
            components.show_error("GitHub CLI (gh) not found. Please install it to create PRs.")
            components.console.print("\n[dim]You can install it from: https://cli.github.com/[/dim]")
        except Exception as e: # Catch any other unexpected error during PR creation
            components.show_error(f"An unexpected error occurred during PR creation: {str(e)}")

def get_repository_info() -> Dict[str, str]:
    """Get repository information.
    
    Returns:
        Dictionary with repository information.
    """
    info = {}
    
    # Get repository URL
    result = subprocess.run(
        ["git", "config", "--get", "remote.origin.url"],
        capture_output=True,
        text=True
    )
    info["url"] = result.stdout.strip()
    
    # Get repository name
    if info["url"]:
        # Extract name from URL
        match = re.search(r"[:/]([^/]+/[^/]+?)(?:\.git)?$", info["url"])
        if match:
            info["name"] = match.group(1)
    
    return info 

def print_pr_commit_hashes(base_branch: str) -> None:
    """Debug utility: Print hashes and messages of commits that would be included in the PR."""
    commits = get_pr_commits(base_branch)
    from gitwise.ui import components
    components.show_section(f"[Debug] Commits for PR (base: {base_branch})")
    for c in commits:
        components.console.print(f"[bold cyan]{c['hash'][:7]}[/bold cyan] {c['message']}") 