"""Pull request creation feature for GitWise."""

# Test comment for PR flow

import subprocess
import re
from typing import List, Dict, Optional, Tuple

from gitwise.features.context import ContextFeature
from gitwise.llm.router import get_llm_response
from ..prompts import PROMPT_PR_DESCRIPTION
from .pr_enhancements import enhance_pr_description, get_pr_labels
from rich.console import Console
from ..ui import components
import os
import tempfile
import typer
from ..llm.offline import ensure_offline_model_ready
from gitwise.config import get_llm_backend, load_config, ConfigError
from ..core.git_manager import GitManager
from .generate import generate_pr_and_commits
from .commit import suggest_commit_groups, safe_confirm, safe_prompt, build_commit_message_interactive

console = Console()


def _clean_pr_body(raw_body: str) -> str:
    """Programmatically cleans the PR body generated by LLM.
    Removes common preamble and unwanted sections like 'Contributors'.
    """
    cleaned_body = raw_body.strip()

    lines = cleaned_body.split("\n")
    start_index = 0
    for i, line in enumerate(lines):
        if line.startswith(("##", "# ", "###", "- ", "* ", "**Summary")):
            start_index = i
            break
        if (
            i < 3
            and not line.startswith("##")
            and not line.startswith("# ")
            and not line.startswith("###")
            and "Summary of Changes" not in line
            and "Key Enhancements" not in line
            and "Key Features" not in line
        ):
            continue
        else:
            if i == 0:  # No preamble found
                start_index = 0
            else:
                start_index = i  # Content started
            break

    if start_index > 0 and start_index < len(lines):
        cleaned_body = "\n".join(lines[start_index:])

    # Remove "Contributors" or "Acknowledgements" sections
    section_patterns_to_remove = [
        r"(^|\n)##?\s*(?:🙏\s*)?(?:Contributors|Acknowledgements|Special Thanks|Next Steps)\s*($|\n).*?(?=(^|\n)##?\s|\Z)"
    ]
    for pattern in section_patterns_to_remove:
        cleaned_body = re.sub(
            pattern, "", cleaned_body, flags=re.IGNORECASE | re.MULTILINE | re.DOTALL
        ).strip()

    return cleaned_body.strip()


def _validate_branch_name(branch: str) -> bool:
    """Validate branch name against naming conventions."""
    # Protected branches
    protected = {"main", "master", "develop"}
    if branch in protected:
        return False

    # Branch name pattern
    pattern = r"^(feature|fix|docs|chore|refactor|test|style|perf|ci|build|revert)/[a-z0-9-]+$"
    return bool(re.match(pattern, branch))


def _get_pr_commits(git_m: GitManager, base_branch: str) -> List[Dict]:
    """Return commits unique to the current branch (not yet merged into base_branch)."""
    try:
        merge_base = git_m.get_merge_base(base_branch, "HEAD")
        if not merge_base:
            components.show_error(f"Could not determine merge base with {base_branch}.")
            return []

        log_range = f"{merge_base}..HEAD"
        components.console.print(
            f"[dim]Analyzing commits in range: {log_range} (Base: '{base_branch}', Merge base: '{merge_base}')[/dim]"
        )
        return git_m.get_commits_between(merge_base, "HEAD")
    except Exception as e:
        components.show_error(f"Failed to get commits for PR: {str(e)}")
        return []


def _generate_pr_title(commits: List[Dict]) -> str:
    """Generate a PR title from a list of commits."""
    if not commits:
        return ""
    first_commit = commits[0]
    title = first_commit["message"].split("\n")[0]
    if len(commits) > 1:
        title = f"{title} (+{len(commits)-1} more commits)"
    return title


def _generate_pr_description_llm(
    commits: List[Dict], repo_url: str, repo_name: str, guidance: str = ""
) -> str:
    """Generate a PR description using LLM prompt with context from ContextFeature."""
    # Get context for the current branch
    context_feature = ContextFeature()
    # First try to parse branch name for context if we don't have it already
    context_feature.parse_branch_context()
    # Then get context as a formatted string for the prompt
    context_string = context_feature.get_context_for_ai_prompt()
    
    # Show visual indication that context is being used
    if context_string:
        # Trim long contexts for display
        display_context = context_string
        if len(display_context) > 100:
            display_context = display_context[:97] + "..."
        components.show_section("Context Used for PR Description")
        components.console.print(f"[dim cyan]{display_context}[/dim cyan]")
        
        # Add context to guidance
        if guidance:
            guidance = f"{context_string} {guidance}"
        else:
            guidance = context_string
    
    # Get information about changed files across all commits
    git_m = GitManager()
    changed_files = set()
    
    # First try to get files from the commits
    for commit in commits:
        if 'files' in commit:
            changed_files.update(commit['files'])
    
    # If that doesn't work, get files from current PR changes
    if not changed_files:
        current_branch = git_m.get_current_branch()
        default_branch = git_m.get_default_remote_branch_name()
        if current_branch and default_branch:
            try:
                files_output = git_m._run_git_command(
                    ["diff", "--name-only", f"origin/{default_branch}...{current_branch}"], 
                    check=False
                )
                if files_output.returncode == 0:
                    changed_files.update(files_output.stdout.strip().split('\n'))
            except:
                pass  # Silently fail if we can't get the file list
    
    # Add file information to guidance
    if changed_files:
        file_info = "\nFiles changed in this PR:\n"
        for file_path in sorted(changed_files):
            if not file_path:  # Skip empty entries
                continue
                
            # Determine file type
            file_type = "Documentation" if file_path.endswith(('.md', '.rst', '.txt')) else "Code"
            if "test" in file_path.lower():
                file_type = "Test"
            elif "docs/" in file_path.lower():
                file_type = "Documentation"
            
            file_info += f"- {file_path} ({file_type})\n"
        
        # Add file information to guidance
        if guidance:
            guidance = f"{guidance}\n\n{file_info}"
        else:
            guidance = file_info
    
    # Remove author names to avoid LLM confusion (was causing "payas module" hallucinations)
    formatted_commits = "\n".join(
        [f"- {commit['message']}" for commit in commits]
    )
    prompt = PROMPT_PR_DESCRIPTION.replace("{{commits}}", formatted_commits).replace(
        "{{guidance}}", guidance
    )
    llm_output = get_llm_response(prompt)
    return llm_output.strip()


def _create_gh_pr(
    title: str,
    body: str,
    base: str,
    current_branch: str,
    labels: List[str],
    draft: bool = False,
) -> None:
    """Internal function to create a pull request using the gh CLI."""
    components.show_section("Creating Pull Request via gh CLI")
    with components.show_spinner("Running `gh pr create`..."):
        try:
            # Check if a PR for this branch already exists
            pr_list_cmd = [
                "gh", "pr", "list", "--head", current_branch, "--base", base,
                "--state", "open", "--json", "url",
            ]
            pr_list_result = subprocess.run(
                pr_list_cmd, capture_output=True, text=True
            )
            if pr_list_result.returncode == 0 and pr_list_result.stdout.strip():
                import json
                pr_list_data = json.loads(pr_list_result.stdout)
                if pr_list_data:
                    pr_url = pr_list_data[0].get("url")
                    components.show_success(
                        f"A pull request for this branch already exists: {pr_url}"
                    )
                    return

            # Create the new PR
            cmd = ["gh", "pr", "create", "--title", title, "--body", body, "--base", base]
            if draft:
                cmd.append("--draft")
            for label in labels:
                cmd.extend(["--label", label])

            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                components.show_success("Pull request created successfully by gh CLI.")
                pr_url = result.stdout.strip()
                components.console.print(f"[bold green]PR URL: {pr_url}[/bold green]")
            else:
                components.show_error("Failed to create pull request via gh CLI.")
                components.console.print(
                    f"[dim]gh stdout:\n{result.stdout}[/dim]\n[dim]gh stderr:\n{result.stderr}[/dim]"
                )
        except FileNotFoundError:
            components.show_error(
                "GitHub CLI ('gh') not found. Please install it to create pull requests."
            )
        except Exception as e:
            components.show_error(f"An unexpected error occurred with gh CLI: {e}")


def _get_repository_info(git_m: GitManager) -> Dict[str, str]:
    """Get repository information.
    Returns:
        Dictionary with repository information.
    """
    info = {}
    try:
        config_get_result = git_m._run_git_command(
            ["config", "--get", "remote.origin.url"], check=False
        )
        info["url"] = (
            config_get_result.stdout.strip()
            if config_get_result.returncode == 0
            else ""
        )
    except RuntimeError as e:
        components.show_warning(f"Could not get remote.origin.url: {e}")
        info["url"] = ""

    if info["url"]:
        match = re.search(r"[:/]([^/]+/[^/]+?)(?:\.git)?$", info["url"])
        if match:
            info["name"] = match.group(1)
        else:
            info["name"] = "repository"
    else:
        info["name"] = "repository"
    return info


def _print_pr_commit_hashes(git_m: GitManager, base_branch: str) -> None:
    commits = _get_pr_commits(git_m, base_branch)
    components.show_section(f"[Debug] Commits for PR are (base: {base_branch})")
    for c in commits:
        components.console.print(
            f"[bold cyan]{c['hash'][:7]}[/bold cyan] {c['message']}"
        )


def _backend_display_name(backend_str: str) -> str:
    """Get backend display name with provider detection for online mode."""
    if backend_str == "online":
        try:
            from gitwise.llm.providers import detect_provider_from_config
            from gitwise.config import load_config
            
            config = load_config()
            provider = detect_provider_from_config(config)
            
            if provider == "google":
                return "Online (Google Gemini)"
            elif provider == "openai":
                return "Online (OpenAI)"
            elif provider == "anthropic":
                return "Online (Anthropic Claude)"
            elif provider == "openrouter":
                return "Online (OpenRouter)"
            else:
                return "Online (Cloud provider)"
        except:
            return "Online (Cloud provider)"
    else:
        return {"ollama": "Ollama (local server)", "offline": "Offline (local model)"}.get(
            backend_str, backend_str
        )


class PrFeature:
    """Handles the logic for creating pull requests from staged files."""

    def __init__(self):
        """Initializes the PrFeature, using a GitManager instance."""
        self.git_manager = GitManager()

    def execute_pr(
        self, auto_confirm: bool = False, draft: bool = False, labels: List[str] = []
    ) -> bool:
        """
        Orchestrates the unified flow for generating a PR and commits from staged files.
        """
        if not self.git_manager.get_changed_file_paths_staged():
            components.show_warning("No files staged. Please stage files to generate a PR.")
            return False

        # Group staged changes
        commit_groups = self._suggest_and_confirm_groups(auto_confirm)

        # Prepare diffs for each group
        diffs_for_llm, original_staged_files = self._prepare_diffs(commit_groups)
        if not diffs_for_llm:
            components.show_error("Could not generate diffs for the staged files. Aborting.")
            return False

        # Generate PR and commit messages from LLM
        generation_result = self._get_generation_from_llm(diffs_for_llm)
        if not generation_result:
            self.git_manager.stage_files(original_staged_files)  # Restore staging
            return False

        # Preview and get user confirmation
        pr_info = generation_result.pull_request
        commit_messages = generation_result.commits
        self._display_pr_preview(pr_info.title, labels, pr_info.body)
        self._display_commits_preview(commit_messages, commit_groups)

        if not auto_confirm:
            if not self._confirm_creation():
                return False # User cancelled

        # Execute commits
        if not self._execute_commits(commit_messages, commit_groups):
            return False # A commit failed

        # Push changes
        if not self._push_changes(auto_confirm):
            return False

        # Create the PR
        return self._create_final_pr(pr_info.title, pr_info.body, draft, labels)

    def _suggest_and_confirm_groups(self, auto_confirm: bool) -> List[Dict]:
        """Suggests commit groups and gets user confirmation."""
        components.show_section("Analyzing staged changes for commit groups")
        staged_files_list = self.git_manager.get_changed_file_paths_staged()
        groups = suggest_commit_groups()

        commit_groups = []
        if groups and len(groups) > 1:
            components.show_section("Suggested Commit Groups")
            for i, group_item in enumerate(groups, 1):
                components.console.print(f"\n[bold]Group {i}:[/bold] {', '.join(group_item['files'])}")

            if auto_confirm or safe_confirm("Proceed with these groups?", default=True):
                commit_groups = groups
            else:
                components.show_warning("Grouping cancelled. Treating all as a single commit.")
                groups = None

        if not commit_groups:
            commit_groups = [{
                "type": "consolidated",
                "name": "all changes",
                "files": staged_files_list,
            }]
        return commit_groups

    def _prepare_diffs(self, commit_groups: List[Dict]) -> Tuple[List[Dict], List[str]]:
        """Unstages files, creates diffs for each group, then restores staging."""
        diffs_for_llm = []
        original_staged_files = self.git_manager.get_changed_file_paths_staged()

        with components.show_spinner("Calculating diffs for each group..."):
            self.git_manager.unstage_all()
            for i, group in enumerate(commit_groups):
                group_id = f"group_{i+1}"
                self.git_manager.stage_files(group['files'])
                diff = self.git_manager.get_staged_diff(is_cached=True)
                if diff:
                    diffs_for_llm.append({"group_id": group_id, "diff": diff})
                self.git_manager.unstage_all()

        self.git_manager.stage_files(original_staged_files) # Restore for safety
        return diffs_for_llm, original_staged_files

    def _get_generation_from_llm(self, diffs_for_llm: List[Dict]):
        """Calls the LLM and returns the structured generation output."""
        context_feature = ContextFeature()
        context_feature.parse_branch_context()
        guidance = context_feature.get_context_for_ai_prompt() or ""
        generation_result = generate_pr_and_commits(diffs_for_llm, guidance=guidance)
        if not generation_result:
            components.show_error("Failed to generate PR and commit messages from LLM.")
        return generation_result

    def _display_pr_preview(self, title: str, labels: List[str], body: str):
        """Displays a preview of the generated PR."""
        components.show_section("🤖 AI Generated Pull Request")
        components.console.print(f"[bold]Title:[/bold] {title}")
        if labels:
            components.console.print(f"[bold]Labels:[/bold] {', '.join(labels)}")
        components.console.print(f"[bold]Body:[/bold]\n{body}")

    def _display_commits_preview(self, commit_messages: List, commit_groups: List[Dict]):
        """Displays a preview of the generated commits."""
        components.show_section("🤖 AI Generated Commit Messages")
        for commit in commit_messages:
            group_id = commit.group_id
            try:
                group_index = int(group_id.split('_')[-1]) - 1
                group_files = commit_groups[group_index]['files']
                components.console.print(f"[bold]For files: {', '.join(group_files)}[/bold]")
                components.console.print("[cyan]> " + commit.message.replace("\n", "\n> ") + "[/cyan]\n")
            except (ValueError, IndexError):
                components.show_warning(f"Could not map commit with group_id '{commit.group_id}' to a file group.")
                components.console.print("[cyan]> " + commit.message.replace("\n", "\n> ") + "[/cyan]\n")

    def _confirm_creation(self) -> bool:
        """Asks the user to confirm, edit, or cancel."""
        choice = safe_prompt(
            "Apply these changes?",
            options=["Create commits and PR", "Edit messages (not implemented)", "Cancel"],
            default="Create commits and PR"
        )
        if choice == 3:  # Cancel
            components.show_warning("Operation cancelled.")
            return False
        if choice == 2:  # Edit
            components.show_warning("Editing is not yet implemented in this flow. Please cancel and edit your files manually if needed.")
            return False
        return True

    def _execute_commits(self, commit_messages: List, commit_groups: List[Dict]) -> bool:
        """Stages and creates each commit."""
        components.show_section("Executing Commits")
        self.git_manager.unstage_all()
        for i, group in enumerate(commit_groups):
            group_id = f"group_{i+1}"
            commit_info = next((c for c in commit_messages if c.group_id == group_id), None)

            if not commit_info:
                components.show_warning(f"No commit message found for group {group_id}. Skipping.")
                continue

            with components.show_spinner(f"Committing group {group_id}..."):
                self.git_manager.stage_files(group['files'])
                if self.git_manager.create_commit(commit_info.message):
                    components.show_success(f"✓ Commit created for {group_id}")
                else:
                    components.show_error(f"✗ Failed to create commit for {group_id}")
                    return False
        return True

    def _push_changes(self, auto_confirm: bool) -> bool:
        """Pushes the new commits to the remote."""
        from gitwise.features.push import PushFeature # Local import to break circular dependency

        push_feature = PushFeature()
        if not push_feature.execute_push(auto_confirm=auto_confirm):
            components.show_error("Failed to push changes. Cannot create PR.")
            return False
        return True

    def _determine_base_branch(self) -> Optional[str]:
        """Determines the base branch for the PR."""
        remote_name = self.git_manager.get_remote_name()
        base_branch = self.git_manager.get_default_remote_branch_name(remote_name)
        if not base_branch:
            components.show_error(f"Could not determine default remote branch for '{remote_name}'.")
        return base_branch

    def _create_final_pr(self, title: str, body: str, draft: bool, labels: List[str]) -> bool:
        """Creates the pull request on GitHub."""
        current_branch = self.git_manager.get_current_branch()
        base_branch = self._determine_base_branch()
        if not current_branch or not base_branch:
            components.show_error("Could not determine current or base branch. Cannot create PR.")
            return False

        _create_gh_pr(title, body, base_branch, current_branch, labels=labels, draft=draft)
        return True
